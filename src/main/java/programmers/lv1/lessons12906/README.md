## 📈 [같은 숫자는 싫어](https://school.programmers.co.kr/learn/courses/30/lessons/12906)

### Solution

```text
정확성  테스트
테스트 1 〉	통과 (0.07ms, 80MB)
테스트 2 〉	통과 (0.19ms, 73.1MB)
테스트 3 〉	통과 (0.24ms, 71.8MB)
테스트 4 〉	통과 (0.28ms, 76.6MB)
테스트 5 〉	통과 (0.18ms, 80.3MB)
테스트 6 〉	통과 (0.19ms, 75.2MB)
테스트 7 〉	통과 (0.11ms, 74.7MB)
테스트 8 〉	통과 (0.19ms, 74.3MB)
테스트 9 〉	통과 (0.22ms, 73.3MB)
테스트 10 〉	통과 (0.19ms, 67.1MB)
테스트 11 〉	통과 (0.18ms, 70.8MB)
테스트 12 〉	통과 (0.09ms, 74MB)
테스트 13 〉	통과 (0.18ms, 75MB)
테스트 14 〉	통과 (0.23ms, 68.1MB)
테스트 15 〉	통과 (0.24ms, 77.6MB)
테스트 16 〉	통과 (0.25ms, 78.2MB)
테스트 17 〉	통과 (0.06ms, 75.9MB)

효율성  테스트
테스트 1 〉	통과 (41.20ms, 115MB)
테스트 2 〉	통과 (42.34ms, 115MB)
테스트 3 〉	통과 (42.86ms, 110MB)
테스트 4 〉	통과 (42.63ms, 115MB)
```

### Solution2

- Deque을 사용하지 않고, ArrayList를 사용함과 동시에 이전 값을 prev 변수에 담아서 비교하는 방식을 택함.
- Deque을 사용한 Solution1이나 Solution2나 둘 다 이전 값을 조회하는데 시간 복잡도는 O(1)에 해당된다.
- 하지만 `peekLast`와 같은 ArrayDeque의 메서드는 내부적으로 덱의 데이터 구조를 조회해야 하고 메모리 접근이 불가피하다.
- 한편 `prev`와 같은 임시변수를 사용하면 이전 값을 계속해서 추적할 수 있어서 따로 스택이나 큐 자료구조에 접근해서 조회할 필요가 없다.
- 따라서 임시 변수를 사용하는 것이 대규모 자료구조에 접근하는 것보다 메모리 관리 측면에서 이점이 있다.

```text
정확성  테스트
테스트 1 〉	통과 (0.04ms, 77.1MB)
테스트 2 〉	통과 (0.07ms, 77.8MB)
테스트 3 〉	통과 (0.09ms, 78.1MB)
테스트 4 〉	통과 (0.08ms, 85.5MB)
테스트 5 〉	통과 (0.08ms, 76.4MB)
테스트 6 〉	통과 (0.07ms, 82.6MB)
테스트 7 〉	통과 (0.16ms, 67MB)
테스트 8 〉	통과 (0.07ms, 76.9MB)
테스트 9 〉	통과 (0.09ms, 68.4MB)
테스트 10 〉	통과 (0.04ms, 71.5MB)
테스트 11 〉	통과 (0.04ms, 79.9MB)
테스트 12 〉	통과 (0.05ms, 82MB)
테스트 13 〉	통과 (0.07ms, 66.6MB)
테스트 14 〉	통과 (0.08ms, 66.7MB)
테스트 15 〉	통과 (0.08ms, 76.4MB)
테스트 16 〉	통과 (0.14ms, 72.5MB)
테스트 17 〉	통과 (0.04ms, 71.7MB)

효율성  테스트
테스트 1 〉	통과 (26.41ms, 110MB)
테스트 2 〉	통과 (23.63ms, 110MB)
테스트 3 〉	통과 (23.49ms, 109MB)
테스트 4 〉	통과 (25.96ms, 111MB)
```